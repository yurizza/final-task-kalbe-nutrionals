# -*- coding: utf-8 -*-
"""customer_clustering.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qWhxLesXeM-uMLr-L6y4qEWywH3GjTJL

## Customer Clustering

**Problem Statement:**
As a Data Scientist at Kalbe Nutritionals, you have been assigned by the marketing team to create customer clusters/segments based on several criteria.

**Objective:**
Create effective customer segmentation. These customer segments will serve as the foundation for the marketing team to provide personalized promotions and sales treatments tailored to each segment.

### Data Preparation
"""

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns
# scalling
from sklearn.preprocessing import StandardScaler
# modelling
from sklearn.cluster import KMeans
#silhoute
import sklearn.cluster as cluster
import sklearn.metrics as metrics

import warnings

# Disable all warnings
warnings.filterwarnings("ignore")

# Or, only disable specific warnings based on category
# Example: Disabling DeprecationWarning
warnings.filterwarnings("ignore", category=DeprecationWarning)

from google.colab import drive
drive.mount('/content/drive')

folder_path='/content/drive/MyDrive/rakamin/kalbe/'

df = pd.read_csv(folder_path+'df_merged.csv')

df.head()

"""### Dataset Understanding"""

df.info()

df.shape

"""### Data aggregation"""

aggregated_data = df.groupby('CustomerID').agg({
    'TransactionID': 'count',
    'Qty': 'sum',
    'TotalAmount': 'sum'
}).reset_index()

aggregated_data.rename(columns={'TransactionID' : "TotalTransaction", 'Qty' : 'TotalQuantity'}, inplace=True)

aggregated_data.head()

aggregated_data.info()

aggregated_data.describe()

sns.pairplot(data = aggregated_data)

# Menghitung korelasi antara variabel
correlation_matrix = aggregated_data[['TotalTransaction','TotalQuantity', 'TotalAmount']].corr()

# Membuat heatmap untuk visualisasi korelasi
plt.figure(figsize=(8, 6))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', center=0)
plt.title('Correlation Heatmap')
plt.show()

"""A strong correlation between features can indicate the presence of clear clusters within the data.

### Kmeans
"""

# Scaling
sc = StandardScaler()
dfoutlier_std = sc.fit_transform(aggregated_data[['TotalTransaction','TotalQuantity','TotalAmount']].astype(float))

new_dfoutlier_std = pd.DataFrame(data = dfoutlier_std, columns = ['TotalTransaction','TotalQuantity','TotalAmount'])

new_dfoutlier_std.head()

sns.pairplot(new_dfoutlier_std)

"""#### Choose best K"""

# Elbow Method
# declare Within-Cluster Sum of Squares (wcss)
wcss = []
for i in range(1, 11):
  kmeans = KMeans(n_clusters = i, init='k-means++', random_state = 42)
  kmeans.fit(new_dfoutlier_std)
  wcss.append(kmeans.inertia_)
fig, ax = plt.subplots(figsize=(10,6))
plt.plot(range(1,11), wcss)
plt.title('The Elbow Method')
plt.xlabel('Number of Clusters')
plt.ylabel('WCSS')
plt.show()

"""from elbow we can choose 3 or 4 cluster.

so we can u silhoute method to find the best number of cluster.
"""

# Silhoute Method
for i in range(2,13):
    labels=cluster.KMeans(n_clusters=i,init="k-means++",random_state=42).fit(new_dfoutlier_std).labels_
    print ("Silhouette score for k(clusters) = "+str(i)+" is "
           +str(metrics.silhouette_score(new_dfoutlier_std,labels,metric="euclidean",random_state=42)))

"""from silhoutte score, 2 is the best number of cluster but for this case we will use 3 clusters."""

# k-means clustering
kmeans = KMeans(n_clusters=3, random_state=42).fit(new_dfoutlier_std)
labels = kmeans.labels_
new_dfoutlier_std['label_kmeans'] = labels

new_dfoutlier_std.head()

colors_cluster=['blue','yellow', 'green']
label_cluster=['cluster 0', 'cluster 1', "cluster 2"]

# PLOTTING
fig = plt.figure(figsize=(10, 8))
ax = fig.add_subplot(111, projection='3d')

# Scatter plot for points in clusters
for cluster_id in range(3):
    cluster_data = new_dfoutlier_std[new_dfoutlier_std["label_kmeans"] == cluster_id]
    ax.scatter(cluster_data["TotalTransaction"], cluster_data["TotalQuantity"], cluster_data["TotalAmount"],
               c=colors_cluster[cluster_id], s=30, edgecolor='green', label=label_cluster[cluster_id])

# Scatter plot for cluster centers (red)
centers = kmeans.cluster_centers_
ax.scatter(centers[:, 0], centers[:, 1], centers[:, 2], c='red', s=200, label='Cluster Centers')

# Set labels and legend
ax.set_xlabel('TotalTransaction')
ax.set_ylabel('TotalQuantity')
ax.set_zlabel('TotalAmount')
ax.legend()

plt.show()

# copy label cluster to origin data
df_customer_clustering = aggregated_data.copy()
df_customer_clustering['cluster'] = kmeans.labels_

df_customer_clustering.head()

# Calculate the average metrics for each cluster, including customer count, mean TotalTransaction, mean TotalQuantity, and mean TotalAmount.
df_customer_clustering.groupby('cluster').agg({'CustomerID':'count',
                                               'TotalTransaction':'mean',
                                               'TotalQuantity':'mean',
                                               'TotalAmount':'mean'
                                               }).sort_values(by='TotalAmount').reset_index()

"""**Cluster 2 has the highest number of customers.**

**Cluster 0 (Moderate Spenders)**: This indicates that customers in this cluster tend to make purchases of moderate quantity and value.

**Cluster 1 (High Value Shoppers)**: This suggests that customers in this cluster tend to make purchases with a high monetary value.

**Cluster 2 (Balanced Shoppers)**: This implies that customers in this cluster exhibit balanced purchasing behavior in terms of both quantity and value.
"""

# save csv
df_customer_clustering.to_csv(folder_path+'df_customer_clustering.csv',index=False)

# Set style
sns.set(style="whitegrid")

# Define colors for clusters
cluster_colors = ['green', 'purple','blue']

# Create scatter plots for each feature pair
feature_pairs = [('TotalTransaction', 'TotalQuantity'), ('TotalTransaction', 'TotalAmount'), ('TotalQuantity', 'TotalAmount')]

for pair in feature_pairs:
    plt.figure(figsize=(10, 6))
    for cluster_num in range(len(cluster_colors)):
        cluster_data = new_dfoutlier_std[new_dfoutlier_std.label_kmeans == cluster_num]
        plt.scatter(cluster_data[pair[0]], cluster_data[pair[1]], color=cluster_colors[cluster_num], label=f'Cluster {cluster_num}')
    plt.xlabel(pair[0])
    plt.ylabel(pair[1])
    plt.title(f'Scatter Plot of {pair[0]} vs {pair[1]}')
    plt.legend()
    plt.show()

"""### Conclusion

Cluster 0 (Moderate Spenders):

    Marketing Strategy: Encourage them to shop more frequently to increase their transaction value. Send marketing product notifications via email.
    Promotions: Offer special promotions and discounts to motivate this cluster to shop more.
    Other Initiatives: Provide incentives such as small points or rewards every time they make a purchase, empowering them to engage in transactions more frequently.

Cluster 2 (Balanced Shoppers):

    Marketing Strategy: Customers in this cluster have medium transaction values, indicating they are moderately active. Focus on maintaining their activity level and building further engagement.
    Promotions: Offer exclusive discounts or special deals available only to customers in this cluster as a form of appreciation.
    Loyalty Program: Provide points or rewards each time they make a purchase. This can enhance engagement and build long-term relationships.

Cluster 1 (High-Value Shoppers):

    Marketing Strategy: Focus on maintaining strong relationships with customers in this cluster, as they significantly contribute to the business.
    Premium Loyalty Program: Introduce a premium loyalty program that offers additional benefits to customers in this cluster. This could include exclusive discounts, early access to new products, or luxurious rewards.
    Cross-Selling and Up-Selling: Based on their previous purchasing patterns, offer complementary products or higher-value items to increase their transaction value.
"""